\chapter{System Overview}

\subsection*{Introduction}
This chapter provides a high-level description of the system's overall functionality, context, and architectural design. The aim is to present how the major parts of the system interact and why the system has been decomposed into specific modules and tiers.

\subsection*{System Overview}
\textbf{CoWriteIA} is an AI-assisted writing platform designed to support writers through various stages of the creative process. The system enables users to:

\begin{itemize}
    \item Create and manage writing projects
    \item Upload and organize documents
    \item Manage character profiles and story elements
    \item Generate and refine written content using AI assistance
\end{itemize}

To efficiently support these features, the system separates concerns into distinct, coordinated components: user interaction, application logic, AI processing, and data management.

\section{Architectural Design}

The architecture of CoWriteIA follows a \textbf{multi-tier model}, combining \textbf{client–server} and \textbf{layered} principles. This structure organizes the system into four logical tiers, each with specific responsibilities to ensure maintainability, scalability, and clarity.

\subsection*{Architectural Tiers}
\begin{table}[htbp]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{@{} l l p{0.5\textwidth} @{}}
\toprule
\textbf{Tier} & \textbf{Component} & \textbf{Responsibilities} \\
\midrule
\textbf{Presentation} & Frontend Application & User interaction, interface rendering, and user input handling \\
\midrule
\textbf{Application Logic} & Backend (API Server) & Authentication, business workflows, and project/document/character management \\
\midrule
\textbf{AI Processing} & Processing Worker & Embeddings generation, semantic retrieval, and AI text generation \\
\midrule
\textbf{Data} & Storage Systems & Structured data, vector storage, and file management \\
\bottomrule
\end{tabular}
\caption{Architectural Tiers and Responsibilities}
\label{tab:tiers}
\end{table}

\subsection*{Data Storage Components}
\begin{itemize}
    \item \textbf{Main Database}: Stores structured system data (users, projects, characters)
    \item \textbf{Vector Database}: Manages embeddings for semantic retrieval and search
    \item \textbf{File Storage}: Handles uploaded documents and exported files
\end{itemize}

\subsection*{Architectural Diagram}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{images/Box-line.png}
    \caption{Box and Line Diagram showing major subsystems and their connections}
    \label{fig:Box-line}
\end{figure}

A detailed architecture diagram illustrating the complete multi-tier structure of CoWriteIA is provided in Appendix C (Figure~\ref{fig:cowriteia-architecture}).

\subsection*{Diagram Development Process}
\begin{itemize}
    \item \textbf{Initial Design Stage}: Create a \textit{Box and Line Diagram} for simpler representation of systems
    \item \textbf{Finalization Stage}: After selecting the architecture style/pattern (MVC, Client-Server, Layered, Multi-tiered), create detailed mapping of modules/components to each part of the architecture
\end{itemize}

\subsection*{Design Principles}
This architectural decomposition supports the system's functional requirements while ensuring:

\begin{itemize}
    \item \textcolor{blue}{\textbf{Flexibility}}: Components can be modified independently
    \item \textcolor{blue}{\textbf{Maintainability}}: Clear separation of concerns simplifies updates and debugging
    \item \textcolor{blue}{\textbf{Scalability}}: Each tier can be scaled independently based on demand
    \item \textcolor{blue}{\textbf{Security}}: Controlled data flow between tiers with proper authentication
\end{itemize}

\subsection*{Key Architectural Decisions}
\begin{itemize}
    \item \textbf{Separation of AI Processing}: Intensive AI tasks are handled by dedicated workers to maintain API responsiveness
    \item \textbf{Multi-tier Structure}: Enables independent development, testing, and deployment of each tier
    \item \textbf{Modular Design}: Supports future enhancements and feature additions
\end{itemize}

% \section{Data Design}
% Explain how the information domain of your system is transformed into data structures. Describe how the major data or system entities are stored, processed, and organized. List any databases or data storage items.

% \section{Domain Model}
% The domain model is a conceptual representation of the various entities, their attributes, and the relationships between them within the system. It serves as a bridge between the requirements and the design of the software, providing a clear understanding of the business domain and how it interacts with the system being developed. 

% A domain model typically includes key components such as:

% \begin{itemize}
%     \item \textbf{Entities}: These are the primary objects within the domain that hold data and represent real-world concepts. Each entity is defined by its attributes and behaviors.
    
%     \item \textbf{Attributes}: Characteristics or properties of the entities that define their state. For example, a "Customer" entity might have attributes such as \texttt{customerID}, \texttt{name}, \texttt{email}, and \texttt{address}.
    
%     \item \textbf{Relationships}: These illustrate how different entities interact with each other. Relationships can be one-to-one, one-to-many, or many-to-many, depending on how entities are associated.
    
%     \item \textbf{Associations}: Connections between entities that help clarify their interdependencies. For instance, a "Product" may be associated with a "Category," indicating the type of product it belongs to.
% \end{itemize}

% By constructing a domain model, developers can better understand the system's requirements, facilitate communication among stakeholders, and guide the subsequent design and implementation phases. It also aids in identifying potential issues early in the development process, ensuring a more robust architecture.

% An example of a domain model for an online shopping system is provided in Appendix B.

\section{Data Design}

The data design of CoWriteIA defines how information within the system is structured, stored, and processed. The system works with several key domains such as users, projects, documents, characters, AI chat sessions, messages, and contextual search results. These domains are transformed into structured data models to ensure efficient storage, retrieval, and processing.

CoWriteIA uses a combination of storage solutions to manage different types of data. A primary database stores structured application data including user accounts, project metadata, documents, characters, dialogues, and chat sessions. A vector database maintains embeddings that support semantic search and retrieval, enabling context-aware AI functionality. File storage is used to save uploaded documents and exported files. Together, these components ensure reliable, scalable, and organized data handling across the system.

The ER diagram (Figure~\ref{fig:erd}) represents the main data entities and their relationships. Each entity is organized into attributes that describe its structure, while relationships define how entities interact. This design supports the project's functional needs such as document management, character creation, AI-assisted writing, and contextual retrieval.

\section{Domain Model}

The domain model provides a conceptual representation of the key entities within CoWriteIA, their attributes, and how they relate to each other. It acts as a bridge between the system’s requirements and its technical design, ensuring that the data structures support the intended workflows and AI-driven processes.

\subsection{Entities and Attributes}

The primary entities in the system include:

\begin{itemize}
    \item \textbf{User}: Represents an individual using the system. Attributes include \texttt{user\_id}, \texttt{name}, \texttt{email}, \texttt{date\_of\_birth}, and \texttt{created\_at}.
    
    \item \textbf{Project}: A writing workspace created by a user. Attributes include \texttt{project\_id}, \texttt{title}, \texttt{description}, and \texttt{created\_at}.
    
    \item \textbf{Document}: Represents any document or chapter within a project. Attributes include \texttt{document\_id}, \texttt{title}, \texttt{content}, and \texttt{events}.
    
    \item \textbf{Character}: Captures a fictional or non-fictional character within a project. Attributes include \texttt{character\_id}, \texttt{name}, \texttt{traits}, \texttt{relationships}, and \texttt{events}.
    
    \item \textbf{ProjectCharacter}: A linking entity showing characters that participate in a project. This helps handle many-to-many relationships between characters and projects.
    
    \item \textbf{Dialogue}: Represents dialogues spoken by characters. Attributes include \texttt{dialogue\_id}, \texttt{context}, and \texttt{content}.
    
    \item \textbf{AI Chat Session}: Represents an AI-driven interaction within a project. Attributes include \texttt{chat\_id} and \texttt{started\_at}.
    
    \item \textbf{Message}: Represents user or AI messages within a chat session. Attributes include \texttt{message\_id}, \texttt{message\_by}, \texttt{content}, and \texttt{timestamp}.
    
    \item \textbf{Internet Search}: Contains contextual internet search results triggered during AI writing sessions. Attributes include \texttt{search\_id}, \texttt{query}, \texttt{result}, and \texttt{url}.
\end{itemize}

\subsection{Relationships and Associations}

The domain model defines several important interactions:

\begin{itemize}
    \item A \textbf{User} creates one or more \textbf{Projects}.
    \item A \textbf{Project} contains many \textbf{Documents}.
    \item A \textbf{Project} also contains many \textbf{Characters} through the \textbf{ProjectCharacter} association.
    \item A \textbf{Character} may speak multiple \textbf{Dialogues}.
    \item A \textbf{User} initiates an \textbf{AI Chat Session}.
    \item Each \textbf{AI Chat Session} contains multiple \textbf{Messages}.
    \item A \textbf{Message} may link to multiple \textbf{Internet Search} results.
\end{itemize}

These relationships create a complete view of the domain, showing how writing elements, AI interactions, and user actions work together. The model ensures that the writing workflow, character development, and AI operations are all fully supported by the underlying data structures.

\subsection{Domain Model Diagram}

Figure~\ref{fig:erd} shows the complete Entity–Relationship Diagram representing the conceptual structure of the system’s data. It outlines all entities, their attributes, and the cardinality of their relationships.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{images/erd.png}
    \caption{Entity–Relationship Diagram for CoWriteIA}
    \label{fig:erd}
\end{figure}



\section{Design Models [UPTO THE CURRENT ITERATION ONLY]}
Create design models as are applicable to your system. Provide detailed descriptions with each of the models that you add. Also ensure visibility of all diagrams. 

\textbf{Design Models for Object Oriented Development Approach}

The applicable models for the project using object oriented development approach may include:

•	Activity Diagram\\
•	Class Diagram\\
•	Class-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\

\textbf{Design Models for Procedural Approach}

The applicable models for the project using procedural approach may include:

•	Activity Diagram\\
•	Data Flow Diagram (data flow diagram should be extended to 2-3 levels. It should clearly list all processes, their sources/sinks and data stores.)\\
•	System-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\


Examples of above diagrams are given in Appendix D.