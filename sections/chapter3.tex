\chapter{System Overview}

\subsection*{Introduction}
This chapter provides a high-level description of the system's overall functionality, context, and architectural design. The aim is to present how the major parts of the system interact and why the system has been decomposed into specific modules and tiers.

\subsection*{System Overview}
\textbf{CoWriteIA} is an AI-assisted writing platform designed to support writers through various stages of the creative process. The system enables users to:

\begin{itemize}
    \item Create and manage writing projects
    \item Upload and organize documents
    \item Manage character profiles and story elements
    \item Generate and refine written content using AI assistance
\end{itemize}

To efficiently support these features, the system separates concerns into distinct, coordinated components: user interaction, application logic, AI processing, and data management.

\section{Architectural Design}

The architecture of CoWriteIA follows a \textbf{multi-tier model}, combining \textbf{client–server} and \textbf{layered} principles. This structure organizes the system into four logical tiers, each with specific responsibilities to ensure maintainability, scalability, and clarity.

\subsection*{Architectural Tiers}
\begin{table}[htbp]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{@{} l l p{0.5\textwidth} @{}}
\toprule
\textbf{Tier} & \textbf{Component} & \textbf{Responsibilities} \\
\midrule
\textbf{Presentation} & Frontend Application & User interaction, interface rendering, and user input handling \\
\midrule
\textbf{Application Logic} & Backend (API Server) & Authentication, business workflows, and project/document/character management \\
\midrule
\textbf{AI Processing} & Processing Worker & Embeddings generation, semantic retrieval, and AI text generation \\
\midrule
\textbf{Data} & Storage Systems & Structured data, vector storage, and file management \\
\bottomrule
\end{tabular}
\caption{Architectural Tiers and Responsibilities}
\label{tab:tiers}
\end{table}

\subsection*{Data Storage Components}
\begin{itemize}
    \item \textbf{Main Database}: Stores structured system data (users, projects, characters)
    \item \textbf{Vector Database}: Manages embeddings for semantic retrieval and search
    \item \textbf{File Storage}: Handles uploaded documents and exported files
\end{itemize}

\subsection*{Architectural Diagram}
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{images/Box-line.png}
    \caption{Box and Line Diagram showing major subsystems and their connections}
    \label{fig:Box-line}
\end{figure}

A detailed architecture diagram illustrating the complete multi-tier structure of CoWriteIA is provided in Appendix C (Figure~\ref{fig:cowriteia-architecture}).

\subsection*{Diagram Development Process}
\begin{itemize}
    \item \textbf{Initial Design Stage}: Create a \textit{Box and Line Diagram} for simpler representation of systems
    \item \textbf{Finalization Stage}: After selecting the architecture style/pattern (MVC, Client-Server, Layered, Multi-tiered), create detailed mapping of modules/components to each part of the architecture
\end{itemize}

\subsection*{Design Principles}
This architectural decomposition supports the system's functional requirements while ensuring:

\begin{itemize}
    \item \textcolor{blue}{\textbf{Flexibility}}: Components can be modified independently
    \item \textcolor{blue}{\textbf{Maintainability}}: Clear separation of concerns simplifies updates and debugging
    \item \textcolor{blue}{\textbf{Scalability}}: Each tier can be scaled independently based on demand
    \item \textcolor{blue}{\textbf{Security}}: Controlled data flow between tiers with proper authentication
\end{itemize}

\subsection*{Key Architectural Decisions}
\begin{itemize}
    \item \textbf{Separation of AI Processing}: Intensive AI tasks are handled by dedicated workers to maintain API responsiveness
    \item \textbf{Multi-tier Structure}: Enables independent development, testing, and deployment of each tier
    \item \textbf{Modular Design}: Supports future enhancements and feature additions
\end{itemize}

% \section{Data Design}
% Explain how the information domain of your system is transformed into data structures. Describe how the major data or system entities are stored, processed, and organized. List any databases or data storage items.

% \section{Domain Model}
% The domain model is a conceptual representation of the various entities, their attributes, and the relationships between them within the system. It serves as a bridge between the requirements and the design of the software, providing a clear understanding of the business domain and how it interacts with the system being developed. 

% A domain model typically includes key components such as:

% \begin{itemize}
%     \item \textbf{Entities}: These are the primary objects within the domain that hold data and represent real-world concepts. Each entity is defined by its attributes and behaviors.
    
%     \item \textbf{Attributes}: Characteristics or properties of the entities that define their state. For example, a "Customer" entity might have attributes such as \texttt{customerID}, \texttt{name}, \texttt{email}, and \texttt{address}.
    
%     \item \textbf{Relationships}: These illustrate how different entities interact with each other. Relationships can be one-to-one, one-to-many, or many-to-many, depending on how entities are associated.
    
%     \item \textbf{Associations}: Connections between entities that help clarify their interdependencies. For instance, a "Product" may be associated with a "Category," indicating the type of product it belongs to.
% \end{itemize}

% By constructing a domain model, developers can better understand the system's requirements, facilitate communication among stakeholders, and guide the subsequent design and implementation phases. It also aids in identifying potential issues early in the development process, ensuring a more robust architecture.

% An example of a domain model for an online shopping system is provided in Appendix B.
\section{Data Design}

The data design of CoWriteIA defines how the information domain is structured, processed, and stored across the system. Since the application involves project creation, collaborative writing, semantic search, character management, and AI-assisted generation, the data layer must support a wide range of structured and unstructured information. To achieve this, the system separates its storage into three main components: a primary database for structured data, a vector database for AI embeddings, and file storage for uploaded and exported documents.

The primary database stores core system entities such as users, projects, project documents, characters, chat sessions, and messages. These entities represent the logical workflow of the writing environment and form the backbone of user interaction and document management. The vector database stores high-dimensional embeddings generated from project content, characters, and dialogues. These embeddings support semantic search, context retrieval, and knowledge-based augmentation during writing sessions. File storage is used for user-uploaded documents and exported project files, ensuring that large files remain efficiently handled outside the main database.

This data separation ensures that the system remains scalable and performant: structured data is retrieved quickly, semantic queries run on optimized vector indexes, and file operations remain independent of database performance. Figure~\ref{fig:domainmodel} illustrates the conceptual domain model that describes how the major data entities relate to each other.

\section{Domain Model}

The domain model serves as a conceptual blueprint of the system, describing the key entities, their attributes, and the relationships that define how information flows throughout CoWriteIA. This model helps translate functional requirements into a structured and understandable design, guiding both implementation and future expansion of the system.

\subsection{Entities and Attributes}

The major entities of the system and their attributes are summarized below:

\begin{itemize}
    \item \textbf{User}: Represents a system user who owns projects and interacts with the AI. Attributes include \texttt{user\_id}, \texttt{name}, \texttt{email}, \texttt{date\_of\_birth}, \texttt{password\_hash}, \texttt{role}, and \texttt{created\_at}.
    
    \item \textbf{Project}: A workspace created by the user. Attributes include \texttt{project\_id}, \texttt{title}, \texttt{created\_at}, and \texttt{updated\_at}.
    
    \item \textbf{Document}: Represents an individual chapter or section of a project. Attributes include \texttt{document\_id}, \texttt{title}, \texttt{order\_num}, \texttt{created\_at}, and \texttt{updated\_at}.
    
    \item \textbf{Character Repository}: A collection of user-defined characters that may be linked to one or more projects.
    
    \item \textbf{Character}: Represents a story character. Attributes include \texttt{character\_id}, \texttt{name}, \texttt{traits}, \texttt{history}, \texttt{created\_at}, and \texttt{updated\_at}.
    
    \item \textbf{ProjectCharacter}: An association class linking projects and characters. It stores project-specific values such as \texttt{age} and \texttt{events}.
    
    \item \textbf{Dialogue}: Represents dialogues spoken by characters. Attributes include \texttt{dialogue\_id}, \texttt{content}, \texttt{context}, and \texttt{emotion\_tag}.
    
    \item \textbf{ProjectDialogue}: A linking entity that associates dialogues with a project.
    
    \item \textbf{Chat Session}: An AI chat interaction initiated by the user. The attribute \texttt{chat\_id} identifies each session.
    
    \item \textbf{Message}: Stores a single message in an AI chat. Attributes include \texttt{message\_id}, \texttt{sent\_by}, \texttt{timestamp}, and \texttt{content}.
    
    \item \textbf{Search Engine}: Represents semantic search functionality within the system.
    
    \item \textbf{Search Result}: Stores contextual results from semantic or internet queries. Attributes include \texttt{result\_id}, \texttt{query}, and \texttt{content}.
    
    \item \textbf{Knowledge Base}: Stores embeddings and their source references. Attributes include \texttt{embedding\_id}, \texttt{vector\_representation}, and \texttt{source\_ids}.
    
    \item \textbf{Exported Project}: Represents generated output files such as PDF or Word exports.
\end{itemize}

\subsection{Relationships and Associations}

The domain model defines a set of structured relationships that map how data flows across CoWriteIA:

\begin{itemize}
    \item A \textbf{User} owns multiple \textbf{Projects}.
    \item A \textbf{Project} contains multiple \textbf{Documents}.
    \item A \textbf{User} owns a \textbf{Character Repository}, which stores many \textbf{Characters}.
    \item A \textbf{Project} includes multiple \textbf{Characters} through the \textbf{ProjectCharacter} association.
    \item A \textbf{Character} speaks one or more \textbf{Dialogues}.
    \item A \textbf{Project} may associate specific dialogues using \textbf{ProjectDialogue}.
    \item A \textbf{User} initiates a \textbf{Chat Session}.
    \item A \textbf{Chat Session} contains multiple \textbf{Messages}.
    \item The \textbf{LLM Chatbot} interacts with both the \textbf{Semantic Search Engine} and the \textbf{Knowledge Base} to generate AI responses.
    \item The \textbf{Search Engine} produces multiple \textbf{Search Results}, which may be injected back into messages or documents.
\end{itemize}

These relationships ensure that writing, search, character creation, and AI chat flows are coherently integrated across all components of the system.

\subsection{Domain Model Diagram}

Figure~\ref{fig:domainmodel} presents the complete domain model for CoWriteIA. It includes all major entities, attributes, and associations, including weak entities and dotted-line conceptual relationships used to illustrate non-key or transitive connections.

\begin{figure}[htbp]
    \centering
    \includegraphics[width=\textwidth]{images/domain.png}
    \caption{Domain Model Diagram for CoWriteIA}
    \label{fig:domainmodel}
\end{figure}




\section{Design Models [UPTO THE CURRENT ITERATION ONLY]}
Create design models as are applicable to your system. Provide detailed descriptions with each of the models that you add. Also ensure visibility of all diagrams. 

\textbf{Design Models for Object Oriented Development Approach}

The applicable models for the project using object oriented development approach may include:

•	Activity Diagram\\
•	Class Diagram\\
•	Class-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\

\textbf{Design Models for Procedural Approach}

The applicable models for the project using procedural approach may include:

•	Activity Diagram\\
•	Data Flow Diagram (data flow diagram should be extended to 2-3 levels. It should clearly list all processes, their sources/sinks and data stores.)\\
•	System-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\


Examples of above diagrams are given in Appendix D.