\chapter{System Overview}

\subsection*{Introduction}
This chapter provides a high-level description of the system's overall functionality, context, and architectural design. The aim is to present how the major parts of the system interact and why the system has been decomposed into specific modules and tiers.

\subsection*{System Overview}
\textbf{CoWriteIA} is an AI-assisted writing platform designed to support writers through various stages of the creative process. The system enables users to:

\begin{itemize}
    \item Create and manage writing projects
    \item Upload and organize documents
    \item Manage character profiles and story elements
    \item Generate and refine written content using AI assistance
\end{itemize}

To efficiently support these features, the system separates concerns into distinct, coordinated components: user interaction, application logic, AI processing, and data management.

\section{Architectural Design}

The architecture of CoWriteIA follows a \textbf{multi-tier model}, combining \textbf{client–server} and \textbf{layered} principles. This structure organizes the system into four logical tiers, each with specific responsibilities to ensure maintainability, scalability, and clarity.

\subsection*{Architectural Tiers}

\begin{table}[ht]
\centering
\renewcommand{\arraystretch}{1.4}
\begin{tabular}{@{} l l p{0.5\textwidth} @{}}
\toprule
\textbf{Tier} & \textbf{Component} & \textbf{Responsibilities} \\
\midrule
\textbf{Presentation} & Frontend Application & 
User interaction, interface rendering, and user input handling \\
\midrule
\textbf{Application Logic} & Backend (API Server) &
Authentication, business workflows, and project/document/character management \\
\midrule
\textbf{AI Processing} & Processing Worker &
Embeddings generation, semantic retrieval, and AI text generation \\
\midrule
\textbf{Data} & Storage Systems &
Structured data, vector storage, and file management \\
\bottomrule
\end{tabular}
\caption{Architectural Tiers and Responsibilities}
\label{tab:tiers}
\end{table}

\subsection*{Data Storage Components}
\begin{itemize}
    \item \textbf{Main Database}: Stores structured system data (users, projects, characters)
    \item \textbf{Vector Database}: Manages embeddings for semantic retrieval and search
    \item \textbf{File Storage}: Handles uploaded documents and exported files
\end{itemize}

\subsection*{Architectural Diagram}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.85\textwidth]{images/Box-line.png}
    \caption{\textbf{Box and Line Diagram} showing major subsystems and their connections}
    \label{fig:Box-line}
\end{figure}

% --- Architectue ---
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.9\textwidth]{images/architecture.png}
    \caption{CoWriteIA System Architecture Diagram showing multi-tier structure}
    \label{fig:architecture-diagram}
\end{figure}
% ----------------------------


\subsection*{Diagram Development Process}

\begin{itemize}
    \item \textbf{Initial Design Stage}: Create a \textit{Box and Line Diagram} for simpler representation of systems
    \item \textbf{Finalization Stage}: After selecting the architecture style/pattern (MVC, Client-Server, Layered, Multi-tiered), create detailed mapping of modules/components to each part of the architecture
\end{itemize}



\subsection*{Design Principles}
This architectural decomposition supports the system's functional requirements while ensuring:

\begin{itemize}
    \item \textcolor{blue}{\textbf{Flexibility}}: Components can be modified independently
    \item \textcolor{blue}{\textbf{Maintainability}}: Clear separation of concerns simplifies updates and debugging
    \item \textcolor{blue}{\textbf{Scalability}}: Each tier can be scaled independently based on demand
    \item \textcolor{blue}{\textbf{Security}}: Controlled data flow between tiers with proper authentication
\end{itemize}

\subsection*{Key Architectural Decisions}
\begin{itemize}
    \item \textbf{Separation of AI Processing}: Intensive AI tasks are handled by dedicated workers to maintain API responsiveness
    \item \textbf{Multi-tier Structure}: Enables independent development, testing, and deployment of each tier
    \item \textbf{Modular Design}: Supports future enhancements and feature additions
\end{itemize}

\section{Data Design}
Explain how the information domain of your system is transformed into data structures. Describe how the major data or system entities are stored, processed, and organized. 

List any databases or data storage items.
\section{Domain Model}
The domain model is a conceptual representation of the various entities, their attributes, and the relationships between them within the system. It serves as a bridge between the requirements and the design of the software, providing a clear understanding of the business domain and how it interacts with the system being developed. 

A domain model typically includes key components such as:

\begin{itemize}
    \item \textbf{Entities}: These are the primary objects within the domain that hold data and represent real-world concepts. Each entity is defined by its attributes and behaviors.
    
    \item \textbf{Attributes}: Characteristics or properties of the entities that define their state. For example, a "Customer" entity might have attributes such as \texttt{customerID}, \texttt{name}, \texttt{email}, and \texttt{address}.
    
    \item \textbf{Relationships}: These illustrate how different entities interact with each other. Relationships can be one-to-one, one-to-many, or many-to-many, depending on how entities are associated.
    
    \item \textbf{Associations}: Connections between entities that help clarify their interdependencies. For instance, a "Product" may be associated with a "Category," indicating the type of product it belongs to.
\end{itemize}

By constructing a domain model, developers can better understand the system's requirements, facilitate communication among stakeholders, and guide the subsequent design and implementation phases. It also aids in identifying potential issues early in the development process, ensuring a more robust architecture.

An example of a domain model for an online shopping system is provided in Appendix B.

\section{Design Models [UPTO THE CURRENT ITERATION ONLY]}
Create design models as are applicable to your system. Provide detailed descriptions with each of the models that you add. Also ensure visibility of all diagrams. 

\textbf{Design Models for Object Oriented Development Approach}

The applicable models for the project using object oriented development approach may include:

•	Activity Diagram\\
•	Class Diagram\\
•	Class-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\

\textbf{Design Models for Procedural Approach}

The applicable models for the project using procedural approach may include:

•	Activity Diagram\\
•	Data Flow Diagram (data flow diagram should be extended to 2-3 levels. It should clearly list all processes, their sources/sinks and data stores.)\\
•	System-level Sequence Diagram\\
•	[OPTIONAL] State Transition Diagram (for the projects which include event handling and backend processes)\\

Examples of above diagrams are given in Appendix D.